--dml문장
INSERT, UPDATE, DELETE

SELECT* FROM DIVISION;



CREATE TABLE MANAGER
AS
	SELECT * FROM PERSONNEL
	WHERE 1=2;

CREATE TABLE SALESMAN
AS
	SELECT * FROM PERSONNEL
	WHERE 1=2;

CREATE TABLE BUSEO
AS SELECT * FROM DIVISION;

CREATE TABLE SAWON
AS SELECT * FROM PERSONNEL;

CREATE TABLE EXAM1
AS SELECT * FROM PERSONNEL;

CREATE TABLE EXAM2
AS SELECT * FROM DIVISION;


SELECT * FROM TAB

SELECT * FROM MANAGER;

SELECT * FROM BUSEO

SELECT * FROM DIVISION;
DESC DIVISION;

INSERT INTO DIVISION VALUES(50,'OPERATION','031-123-1234','DAEGU');
SELECT * FROM DIVISION;

DESC PERSONNEL;
INSERT INTO PERSONNEL(PNO, PNAME, PAY, DNO) VALUES(7711, 'YOUNG', 4000, 20)
SELECT * FROM PERSONNEL;


--NULL 입력
INSERT INTO DIVISION(DNO, DNAME, PHONE) VALUES (80, 'PLANNING', '010-1234-1234')
INSERT INTO DIVISION VALUES (90, 'ACCOUNT', '011-342-1234', NULL)
INSERT INTO DIVISION (DNAME) VALUES ('SALES');  --X
DESC DIVISION

INSERT INTO PERSONNEL(PNO, PNAME, JOB, STARTDATE, DNO)
VALUES(1304, 'YOU', 'SALESMAN', SYSDATE, 10);

SELECT * FROM PERSONNEL;

DESC MANAGER;
SELECT COUNT(*) FROM MANAGER;
SELECT * FROM PERSONNEL;

INSERT INTO MANAGER
SELECT * FROM PERSONNEL WHERE JOB = 'MANAGER';

SELECT * FROM MANAGER;

SELECT * FROM SALESMAN;

INSERT INTO SALESMAN(PNO, PNAME, PAY, STARTDATE)
SELECT PNO, PNAME, PAY, STARTDATE FROM PERSONNEL
WHERE JOB = 'SALESMAN';


--문제 설명
SELECT extract(year FROM startdate) FROM PERSONNEL;
SELECT TO_CHAR(startdate,'yyyy') FROM PERSONNEL;

SUM(WHEN 1990 THEN 1 ELSE 0 END)
WHEN 1990 THEN 1 ELSE 0 END)


치환변수
SELECT PNO, PNAME, JOB, STARTDATE, DNO FROM PERSONNEL WHERE DNO=&DIV_DNO;

--UPDATE

--사원번호가 1111인 사원의 부서를 30으로 수정
SELECT * FROM PERSONNEL WHERE PNO=1111;

UPDATE PERSONNEL SET DNO=30 WHERE PNO=1111;

--SAWON테이블의 모든 사원의 부서번호를 20으로 수정

SELECT * FROM SAWON;
UPDATE SAWON SET DNO=20;

UPDATE SAWON SET PNAME='SUZI', JOB='SINGER', MANAGER=1111,PAY=5000
WHERE PNO=1113


SELECT* FROM PERSONNEL
WHERE DNO=(SELECT DNO FROM DIVISION WHERE DNAME='SALES')

UPDATE PERSONNEL SET JOB='SALESMAN'
WHERE DNO=(SELECT DNO FROM DIVISION WHERE DNAME='SALES')

--DELETE
--사원번호가 1300인 사원을 삭제
SELECT * FROM PERSONNEL
WHERE PNO=1123;

DELETE FROM PERSONNEL
WHERE PNO=1123;

SELECT * FROM BUSEO;

SELECT * FROM PERSONNEL;

--INSERT에러
SELECT * FROM PERSONNEL;

DESC PERSONNEL;

SELECT * FROM USER_CONSTRAINTS;
PRIMARY KEY(주키)
중복값을 허용안함
NOT NULL
테이블에 1개만 생성가능

INSERT INTO PERSONNEL (PNAME) VALUES('AAAA');

--수정이불가능한경우

SELECT * FROM DIVISION;
SELECT * FROM PERSONNEL;

FOREIGN KEY(외부참조키)

INSERT INTO PERSONNEL (PNO, DNO) VALUES(1234,10);

SELECT * FROM PERSONNEL;

INSERT INTO PERSONNEL (PNO, DNO) VALUES(1233,15);
--위에 DNO에 없어 안됨
SELECT * FROM PERSONNEL;

UPDATE PERSONNEL SET DNO = 16
WHERE PNO=1111;

DELETE DIVISION WHERE PNO=30;

SELECT * FROM USER_CONSTRAINTS;
SELECT COUNT(*) FROM DICTIONARY;

--TRANSACTION
여러개의 작업을 1개의 작업으로 처리

SELECT * FROM PERSONNEL;

DELETE PERSONNEL WHERE PNO=1112;













--DDL(CREATE,ALTER,drop)
--OBJECT(TABLE,INDEX,SYNONYM,VIEW)


--TABLE
/*
CHAR : 문자(고정길이) , 사이즈가 모두 똑같다. 읽는속도가 빠르다.
VARCHAR2 : 문자(가변길이) , 필요한만큼만 쓰고 빈공간을 돌려준다. 메모리낭비안한다.

NUMBER(P,S) : 숫자(가변길이)
DATE : 날짜,시간(고정길이,7BYTE)
LONG : 문자(가변길이,2GB)
*/

1. 영문자로시작(30자)
2. 영문자, 숫자만 가능(공백X)
3. 특수문자(_,$,#만 가능)
4. 이름중복안됨
5. 컬럼과 같으면 안됨
6. 예약어 사용못함(CREATE, ALTER)

CREATE TABLE BUSE01
(DNO NUMBER(2) PRIMARY KEY,
DNAME VARCHAR2(14) NOT NULL,
ZIPCODE CHAR2(7));

INSERT INTO BUSE01(DNO, DNAME, ZIPCODE) VALUES(10,'SALES','123-123');
SELECT * FROM BUSE01;

CREATE TABLE MEMBER
(USERID CHAR(5) PRIMARY KEY,
USERPWD CHAR(8) NOT NULL,
USERNAME CHAR(10),
USERADDR VARCHAR2(50),
USERBIRTH DATE,
USERNUMIN CHAR(14));

DESC MEMBER;
SELECT * FROM TABS;
SELECT * FROM TAB
INSERT INTO MEMBER VALUES ('A0001','123','KIM','SEOUL',
'1994-10-10','123456-1234567');

SELECT * FROM MEMBER;

--SUBQUERY를 사용해서 생성
SELECT * FROM TAB;

CREATE TABLE SALESMAN1
AS
SELECT PNO,PNAME,JOB,PAY FROM PERSONNEL
WHERE JOB='SALESMAN';

SELECT * FROM SALESMAN1;

CREATE TABLE PAY3000
AS SELECT * FROM PERSONNEL WHERE PAY>=3000;

SELECT * FROM PAY3000;

--PERSONNEL에서 12월달에 입사한 직원의 데이터를 MON12라는 테이블로 복사
CREATE TABLE MON12
AS SELECT * FROM PERSONNEL WHERE STARTDATE LIKE '%-12-%';

SELECT * FROM MON12

CREATE TABLE SAWON1
AS
SELECT * FROM PERSONNEL
WHERE 1=0;

SELECT * FROM SAWON1;

DESC SALESMAN1

SELECT * FROM SALESMAN1

--컬럼추가
ALTER TABLE SALESMAN1
ADD DNO NUMBER(2);

INSERT INTO SALESMAN1 VALUES (1111,'KIM','SALESMAN',3000,30);

--CHECK

ALTER TABLE SALESMAN1
ADD (JUMIN CHAR(14),ZIP CHAR(7));

SELECT* FROM SALESMAN1;

--CHECK
ALTER TABLE SALESMAN1
ADD (MARRIAGE CHAR(8) CHECK(MARRIAGE IN('SINGLE','MARRIED')));

SELECT * FROM SALESMAN1;

INSERT INTO SALESMAN1 (PNO, MARRIAGE)
VALUES(2222, 'SINGLE');

--SINGLE, MARRIED 빼고는 못들어간다.
INSERT INTO SALESMAN1 (PNO, MARRIAGE)
VALUES(3333, 'SOLO');

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='SALESMAN1';


ALTER TABLE SALESMAN1
ADD CONSTRAINT SALESMAN1_PNO_PK PRIMARY KEY(PNO);


CREATE TABLE PER1
AS
SELECT * FROM PERSONNEL;

DESC PERSONNEL;
DESC PER1;

ALTER TABLE PER1
ADD CONSTRAINT PER1_PNO_PK PRIMARY KEY(PNO);

SELECT * FROM PER1;

SELECT * FROM PER1;

INSERT INTO PER1(PNO) VALUES(1112);

DELETE PER1 WHERE PNO=1112 AND PNAME IS NULL;

ALTER TABLE PER1
ADD CONSTRAINT PER1_PNO_PK PRIMARY KEY(PNO);

DESC PER1

--컬럼수정
--PNAME VARCHAR2(9)를 수정한다.
DESC MANAGER;

ALTER TABLE MANAGER
MODIFY PNAME VARCHAR2(16);

ALTER TABLE MANAGER
MODIFY PNAME VARCHAR2(7);


SELECT * FROM MANAGER;

컬럼에 데이터가 없으면
문자<->숫자<->날짜, 확대, 축소 가능

컬럼에 데이터가 있으면
CHAR<-> VARCHAR2, 확대 가능

--수정방법
INSERT INTO MANAGER VALUES (1111,'SMITH','MANAGER',1001,'1990-12-17',1000,300,10);





--DROP(삭제) 20141016

ALTER TABLE MANAGER
ADD CONSTRAINT MANAGER_PNO_PK PRIMARY KEY(PNO);

SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'MANAGER';


--제약조건삭제1
ALTER TABLE MANAGER
DROP CONSTRAINT MANAGER_PNO_PK;

--제약조건삭제2
ALTER TABLE MANAGER
DROP PRIMARY KEY;


SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'SALESMAN1';

--제약조건삭제1
ALTER TABLE SALESMAN1
DROP CONSTRAINT SALESMAN1_PNO_PK;

SELECT * FROM SALESMAN1
DROP CONSTRAINT SYS_C0011073;

--컬럼삭제
DESC SALESMAN1

ALTER TABLE SALESMAN1
DROP COLUMN MARRIAGE;


-- SET UNUSED, DNO라는 컬럼이 실제로 지워지지 않음 . 보이지 않으며 플레그로 표시
SELECT * FROM SALESMAN1;

ALTER TABLE SALESMAN1
SET UNUSED COLUMN DNO;

--진짜삭제 , SYS에서 확인하면 안나옴(SELECT * FROM DBA_UNUSED_COL_TABS;)
ALTER TABLE SALESMAN1
DROP UNUSED COLUMNS;

--테이블 삭제
BIN$qTcRYtMsRV+oezcL/MRvMA==$0

--지움
DROP TABLE MANAGER;
--BIN$qTcRYtMsRV+oezcL/MRvMA==$0 휴지통

SELECT OBJECT_NAME, ORIGINAL_NAME,DROPTIME
FROM RECYCLEBIN;
--                   진짜이름, 삭제시간

--휴지통에 들어간내용 복원
FLASHBACK TABLE MANAGER TO BEFORE DROP;

--MANAGER테이블 복원확인
SELECT * FROM TAB;


--다시한번삭제
DROP TABLE MANAGER;

SELECT OBJECT_NAME, ORIGINAL_NAME,DROPTIME
FROM RECYCLEBIN;

FLASHBACK TABLE MANAGER TO BEFORE DROP;
FLASHBACK TABLE "BIN$icWaPis9TIG1KK1R6kl41A==$0" TO BEFORE DROP;

--휴지통을 거치지않고 바로삭제
DROP TABLE MANAGER PURGE;

SELECT * FROM TAB;




--TRUNCATE/DELETE비교




SELECT * FROM PERSONNEL;

--삭제
DELETE FROM PERSONNEL;

--확인
SELECT * FROM PERSONNEL;

ROLLBACK;

--삭제된 테이블 복원
SELECT * FROM PERSONNEL;

--------------------------
-- TRUNCATE는 로그파일에 기록하지않고 삭제 . 롤백이 안먹힘
-- 유일한방법은 시간을돌려복구, 1분전?
-- TRUNCATE 테이블을 지우는게 아닌 레코드 삭제

TRUNCATE TABLE PERSONNEL;
SELECT * FROM PERSONNEL;

ROLLBACK;

SELECT * FROM PERSONNEL;


--RENAME
SELECT * FROM PAY3000;

RENAME PAY3000 TO HIGHPAY;
SELECT * FROM TAB


--commnet(주석)

SELECT * FROM user_tab_comments;

--주석달기
COMMENT ON TABLE HIGHPAY
IS '월급 많이 받는직원';

SELECT * FROM USER_COL_COMMENTS;

--주석삭제

COMMENT ON TABLE HIGHPAY IS '';

--컬럼에 주석 :BUSEO	POSITION	여기 주석 보이냐?
COMMENT ON COLUMN BUSEO.POSITION
IS '여기 주석 보이냐?';

--주석확인
SELECT * FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'BUSEO';


-- DCL
-- GRANT : 권한 부여
-- REVOKE : 권한 회수

SELECT * FROM TAB;

SELECT * FROM ABC;
INSERT INTO ABC VALUES(111);

--TEST계정에 SELECT 권한부여
GRANT SELECT ON PERSONNEL TO TEST;

INSERT INTO PERSONNEL(PNO) VALUES(1000);
INSERT INTO PERSONNEL(PNO) VALUES(2000);
INSERT INTO PERSONNEL(PNO) VALUES(3000);

SELECT * FROM PERSONNEL;

COMMIT;

GRANT SELECT, INSERT, DELETE ON DIVISION TO GILDONG;

--누가누구에게 어떤권한을 주었는지 보여준다.
SELECT * FROM USER_TAB_PRIVS_MADE;

--권한회수
REVOKE SELECT ON DIVISION FROM GILDONG;

--권한회수 한번에
REVOKE DELETE, INSERT ON DIVISION FROM GILDONG;

REVOKE SELECT ON PERSONNEL FROM TEST;

--모든사용자가 PUBLIC 권한을 갖게된다.
GRANT SELECT ON DIVISION TO PUBLIC;

--따로 특정사용자의 권한은 못빼냄, PUBLIC으로 권한을 회수
REVOKE SELECT ON DIVISION FROM PUBLIC;

-------------------------------------------------------

--ROLE

--OBJ에 권한주기
GRANT SELECT, INSERT, DELETE ON DIVISION TO OBJ;


--KEYS (PRIMARY/UNIQUE/FOREIGN/CHECK/NOT NULL)
CREATE TABLE customer (id number(4) CONSTRAINT customer_id_pk PRIMARY KEY,
name VARCHAR2(20), NO number(4));

CREATE TABLE orders (NO NUMBER(4), sno NUMBER(4), name VARCHAR2(10), COUNT number(7), CONSTRAINT order_no_pk PRIMARY KEY(no));

SELECT * FROM user_CONSTRAINTs
WHERE table_name='CUSTOMER' OR table_name='ORDERS';

--FOREIGN KEY(외부참조키)
DESC CUSTOMER;
DESC ORDERS;

ALTER TABLE CUSTOMER
ADD CONSTRAINT CUSTOMER_NO_FK FOREIGN KEY(NO)
REFERENCES ORDERS(NO);


SELECT * FROM ORDERS;
SELECT * FROM CUSTOMER;

INSERT INTO ORDERS VALUES(10,100,'AAA',10);
INSERT INTO ORDERS VALUES(20,200,'BBB',20);
INSERT INTO ORDERS VALUES(30,300,'CCC',30);
INSERT INTO ORDERS VALUES(40,400,'DDD',40);

SELECT * FROM CUSTOMER;

INSERT INTO CUSTOMER VALUES ('001','AAA',20);
INSERT INTO CUSTOMER VALUES ('002','BBB',50); --X

CREATE TABLE CATALOG
(CATALOGNO NUMBER(4) CONSTRAINT CATALOG_CATALOGNO_PK PRIMARY KEY,
NAME VARCHAR2(10),
NO NUMBER(4) CONSTRAINT CATALOG_NO_FK REFERENCES ORDERS(NO));


SELECT * FROM user_CONSTRAINTs
WHERE table_name='CUSTOMER' OR table_name='ORDERS'OR table_name='CATALOG';

--UNIQUE
--중복값 허용안함
--NULL은 허용

--UNIQUE 제약조건이 만들어짐
ALTER TABLE ORDERS
ADD CONSTRAINT ORDERS_SNO_UK UNIQUE(SNO);


SELECT * FROM ORDERS;

--UNIQUE 중복값 허용안함
--400 중복값이라 넣을수 없다.
INSERT INTO ORDERS VALUES(50,400,'EEE',50); --X
INSERT INTO ORDERS VALUES(50,NULL,'EEE',50); --ㅇ NULL은 허용
INSERT INTO ORDERS VALUES(60,NULL,'FFF',60); --ㅇ NULL은 허용

CREATE TABLE TEST
(ID NUMBER,
NAME VARCHAR2(10),
JUMIN VARCHAR(14) CONSTRAINT TEST_JUMIN_UK UNIQUE,
AGE NUMBER(3) DEFAULT 20);

SELECT * FROM TEST
INSERT INTO TEST (ID, NAME, JUMIN) VALUES (111,'KIM','111');
INSERT INTO TEST (ID, NAME, JUMIN) VALUES (222,'LEE','111'); ---X
INSERT INTO TEST (ID, NAME, JUMIN) VALUES (222,'NULL',''); --NULL 허용



--CHECK 제약조건
SELECT * FROM ORDERS;

--실습을위해 필요없는거 삭제 (NULL값)
DELETE ORDERS WHERE NO IN(50,60);

--100~500 제약조건
ALTER TABLE ORDERS
ADD CONSTRAINT ORDERS_SNO_CK CHECK(SNO BETWEEN 100 AND 500);


--확인방법
SELECT * FROM user_CONSTRAINTs
WHERE table_name='CUSTOMER' OR table_name='ORDERS'OR table_name='CATALOG';

--테스트
INSERT INTO ORDERS VALUES (50,501,'FFF','50'); -- 501 안됨
INSERT INTO ORDERS VALUES (50,499,'FFF','50'); -- 499 가능
INSERT INTO ORDERS VALUES (60,500,'FFF','60'); -- 500 가능


--NOT NULL
CREATE TABLE TEST1
(NO NUMBER(4) CONSTRAINT TEST1_NO_NN NOT NULL);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME ='TEST';

--CHEAK제약조건으로 NOT NULL을 만들음
ALTER TABLE ORDERS
ADD CONSTRAINT ORDERS_NAME_NN CHECK(NAME IS NOT NULL);


SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME ='TEST1' OR TABLE_NAME= 'ORDERS';

--제약삭제
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME ='CUSTOMER' OR TABLE_NAME= 'ORDERS' OR TABLE_NAME='CATALOG';

ALTER TABLE CATALOG
DROP PRIMARY KEY;

ALTER TABLE CUSTOMER
DROP CONSTRAINT CUSTOMER_ID_PK;

--CASCADE 옵션 : 강제
ALTER TABLE ORDERS
DROP PRIMARY KEY CASCADE;;
-- 3개의 제약조건이 모두 삭제

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='DIVISION' OR TABLE_NAME='PERSONNEL';

SELECT * FROM DIVISION;
SELECT * FROM PERSONNEL;

INSERT INTO PERSONNEL (PNO, DNO) VALUES (4000, 99);

INSERT INTO PERSONNEL (PNO, DNO) VALUES (5000, "");

ALTER TABLE DIVISION
DISABLE PRIMARY KEY CASCADE;

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='DIVISION' OR TABLE_NAME='PERSONNEL';

ALTER TABLE DIVISION
ENABLE PRIMARY KEY;

ALTER TABLE PERSONNEL
ENABLE CONSTRAINT PERSONNEL_DNO_FK;

