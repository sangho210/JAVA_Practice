
--JOIN VIEW
--COMPLEX VIEW(조인으로 만든뷰)
SELECT * FROM CUSTOM;
SELECT * FROM COMPANY;

CREATE VIEW CUSCOM_V
AS SELECT AA.USERID, USERNAME, AGE, ADDR1, COMPANY, POSIT, PAY
FROM CUSTOM AA, COMPANY BB
WHERE AA.USERID = BB.USERID

SELECT * FROM CUSCOM_V -- 조인으로 묶은뷰가 보여진다.

INSERT INTO CUSCOM_V (USERID, USERNAME, POSIT)
VALUES('A0001', 'KIM', '이사', '100000');          --집어넣을수없다. TOO MANY VALUES에러

CREATE TABLE 고객정보
(고객정보 CHAR(10),
이름 CHAR(10));

CREATE TABLE 회사정보
(고객정보 CHAR(10),
회사명 CHAR(10));

INSERT INTO 고객정보 VALUES('A0001', '수지');
INSERT INTO 고객정보 VALUES('A0002', '초아');


SELECT * FROM 고객정보;

INSERT INTO 회사정보 VALUES('A0001', 'LG');
INSERT INTO 고객정보 VALUES('A0002', 'HYUNDAI');

SELECT * FROM 회사정보;

CREATE VIEW 정보
AS
SELECT AA.고객정보, 이름, 회사명
FROM 고객정보 AA, 회사정보 BB
WHERE AA.고객정보 = BB.고객정보

SELECT * FROM 정보;

INSERT INTO 정보 VALUES('A0003', '송이',  'SAMSUNG'); --XX
--에러가난다. 조인을해서

INSERT INTO 정보(고객정보,이름) VALUES('A0003', '송이'); --XX
-- 따로 필요한 컬럼만 하는 입력도 에러남.
INSERT INTO 정보(회사명) VALUES ('SAMSUNG'); --XX

UPDATE 정보 SET 이름='지현' WHERE 고객정보= 'A0001'; --XX
DELETE 정보 WHERE 고객정보 = 'A0001'; --XX

--WITH CHECK OPTION
CREATE OR REPLACE VIEW CUS20_V
AS
SELECT * FROM CUSTOM WHERE AGE=20;
--나이가 20살인 사람만 뷰를 만들어라

SELECT * FROM CUS20_V;

UPDATE CUS20_V SET AGE=30 WHERE USERID='af2457';

--view를 수정

CREATE OR REPLACE VIEW CUS30_V
AS
SELECT * FROM CUSTOM WHERE AGE=20
WITH CHECK OPTION CONSTRAINT CUS20_VU_CK;

UPDATE CUS20_V SET AGE=30 WHERE USERID='rw2201';

UPDATE CUS20_V SET AGE=30 WHERE USERID='af2457';

SELECT * FROM CUS20_V;

--WIEH READ ONLY
CREATE OR REPLACE VIEW CUS20_V
AS
SELECT * FROM CUSTOM WHERE AGE=20
WITH READ ONLY;

DELETE CUS20_V WHERE USERID='af2457';

SELECT * FROM CUS20_V;

--TOP-N 암기하기
SELECT * FROM (
SELECT ROWNUM AS RNUM, DATA.* FROM
(SELECT USERID, USERNAME, ADDR1, AGE FROM CUSTOM
ORDER BY AGE DESC) DATA)
WHERE RNUM <=10;

--MS-SQL 같은방법
SELECT ROWNUM AS RNUM,  DATA.*
FROM (SELECT USERID, USERNAME, ADDR1, AGE FROM CUSTOM ORDER BY AGE) DATA
WHERE ROWNUM<=10;


--MS-SQL에서는 이렇게도 된다
SELECT TOP 10 USERID, USERNAME, ADDR1, AGE FROM CUSTOM ORDER BY AGE DESC;

--열증가번호는 이렇게 만든다. MS SQL에서는
CREATE TABLE AAA
(ID INT IDENTITY(1,1),  --1에서부터 1씩 증가해라. --AUTOINCREMENT
NAME CHAR(10));

--SYNONYM(동의어)
CREATE SYNONYM CUS
FOR CUSTOM;

SELECT * FROM CUS;

SELECT * FROM TAB;

--삭제방법
DROP SYNONYM CUS;


--INDEX

SELECT * FROM CUSTOM;

CREATE INDEX CUS_IDX
ON CUSTOM(AGE);

SELECT * FROM USER_INDEXES

SELECT * FROM CUSTOM
WHERE AGE <= 30;


SELECT * FROM USER_CONSTRAINTS;

CREATE TABLE ABC
(ID NUMBER CONSTRAINT PK_ABC_ID PRIMARY KEY);

SELECT * FROM USER_CONSTRAINTS;

SELECT * FROM USER_INDEXES
WHERE TABLE_NAME='ABC'



SELECT * FROM USER_IND_COLUMNS;


--SEQUENCE(일련번호)

SELECT ROWNUM, USERNAME FROM CUSTOM;

CREATE SEQUENCE DIV_DNO
INCREMENT BY 1  								--증가값
START WITH 1          					--시작값
MAXVALUE 100 | NOMAXVALUE 			-- 100까지  | 무제한
CYCLE | NOCYCLE     						--
CACHE 20 | NOCACHE    					--일렬번호가필요 (한번에 20개씩)


CREATE SEQUENCE DIV_DNO
START WITH 90
INCREMENT BY 1
MAXVALUE 99     --99번까지쓰면 더이상 쓰지마.
NOCYCLE
NOCACHE  --1발1발 사용해라

NEXTVAL : 다음번호(SEQUENCE 이름.NEXTVAL)
CURRVAL : 현재번호(SEQUENCE 이름.CURRVAL)

SELECT DIV_DNO.NEXTVAL FROM DUAL;
SELECT DIV_DNO.CURRVAL FROM DUAL;

SELECT * FROM JEJU

INSERT INTO JEJU (USERID, USERNAME, AGE)
VALUES('A0011','KIM',DIV_DNO.NEXTVAL);

INSERT INTO JEJU (USERID, USERNAME, AGE)
VALUES('A0022','KIM1',DIV_DNO.NEXTVAL);

ALTER SEQUENCE DIV_DNO
INCREMENT BY 10
MAXVALUE 999
CACHE 20
NOCYCLE;

SELECT * FROM USER_SEQUENCES;

INSERT INTO JEJU (USERID, USERNAME, AGE)
VALUES('A0044','KIM3',DIV_DNO.NEXTVAL);


SELECT * FROM JEJU