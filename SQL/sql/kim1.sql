

--함수
--숫자함수
--ROUND(반올림)
SELECT ROUND(45.275,1) FROM DUAL;--45.3
SELECT ROUND(45.275,-1) FROM DUAL;--50
SELECT ROUND(45.275,0) FROM DUAL;--45
SELECT ROUND(45.275) FROM DUAL;--45
-------------------------
 1  2  3  4  .  5  6  7
-4 -3 -2 -1  0  1  2  3
-------------------------
SELECT ROUND(-45.275,2) FROM DUAL;
SELECT ROUND(-45.275,-1) FROM DUAL;

SELECT PNO,PNAME,PAY,ROUND(PAY,-2) FROM PERSONNEL
1600 -> 1600
1450 -> 1500

--TRUNC(절삭)-내림
SELECT TRUNC(45.245,2) FROM DUAL;

SELECT TRUNC(49.245,-1) FROM DUAL;

SELECT PNO,PNAME,PAY,TRUNC(PAY,-2) FROM PERSONNEL;

--CEIL/FLOOR(올림/내림)
SELECT CEIL(461.21) FROM DUAL;

SELECT FLOOR(461.91) FROM DUAL;

--MOD(나머지)
SELECT MOD(10,3) FROM DUAL;

--ABS(절대값)
SELECT ABS(-123) FROM DUAL;

--SIGN(양수 : 1 음수 : -1 영: 0)
SELECT SIGN(100-50), SIGN(50-100), SIGN(100-100) FROM DUAL

SELECT POWER(2,4) FROM DUAL;

SELECT SQRT(16) FROM DUAL; --제곱근

--문자함수
--UPPER(대문자로 바꾸는 함수)
SELECT UPPER('Oracle') FROM DUAL;

--LOWER
SELECT LOWER('ORACLE') FROM DUAL;

SELECT DNO,DNAME FROM DIVISION WHERE DNAME=UPPER('sales');

SELECT DNO,DNAME FROM DIVISION WHERE LOWER(DNAME) = 'sales'

--INITCAP(각 첫글자만 대문자로 바뀐다)
SELECT INITCAP('korea figthting') FROM DUAL;

--CONCAT
SELECT PNAME || DNO FROM PERSONNEL;
SELECT CONCAT(PNAME,DNO) FROM PERSONNEL; --애는 2개 박에 안되

--LENGTH
SELECT LENGTH('KOREA') FROM DUAL;
SELECT LENGTH('KOREA F') FROM DUAL;--공백도 포함한다.

--SUBSTR(문자추출)
SELECT SUBSTR('ABCDEFG', 1,3) FROM DUAL --첫번째에서 3번째까지
SELECT SUBSTR('ABCDEFG', 3,2) FROM DUAL --3번째부터 2번째가지
SELECT SUBSTR('ABCDEFG', -3,2) FROM DUAL --뒤에서 3번째부터 2번째까지
SELECT SUBSTR('ABCDEFG', -4) FROM DUAL --뒤에서 4번째부터 끝까지

--INSTR
SELECT INSTR('ABCDEFG', 'C') FROM DUAL --C의 인덱스 값
SELECT INSTR('AAAAAAA', 'A') FROM DUAL --A가 많지만 첫번째값만 받아들인다.
SELECT INSTR('ABCDEFG', 'a') FROM DUAL --값이 없기 때문에 0 나온다

--RPAD/LPAD
SELECT RPAD(PNAME,15,'*') FROM PERSONNEL; --15자리를 만드는데 PNAME을 제외하고 나머지 자리는 * 표시
SELECT LPAD(PNAME,15,'*') FROM PERSONNEL; --애는 똑같은데 반대쪽으로
SELECT * FROM DIVISION

--RTRIM/LTRIM
SELECT RTRIM('ABBBB' ,'B') FROM DUAL
SELECT RTRIM('A    B',' ') FROM DUAL

SELECT LTRIM('BBBBBABB', 'B') FROM DUAL

--날짜함수
--SYSDATE(오늘날짜)
SELECT SYSDATE + 10 FROM DUAL --연산도 가능

SELECT STARTDATE, STARTDATE+10 FROM PERSONNEL

--KIM사원이 현재까지 근무한 년수를 구하시오
SELECT * FROM PERSONNEL WHERE PNAME = 'KIM';
SELECT STARTDATE, SUBSTR(SYSDATE,1,4)-SUBSTR(STARTDATE,1,4) "근무년수"
FROM PERSONNEL WHERE PNAME = 'KIM';

--ROUND
SELECT STARTDATE,ROUND(STARTDATE, 'YEAR') FROM PERSONNEL
WHERE PNAME = 'KIM' --6월30일 기준으로 반올림

SELECT STARTDATE,ROUND(STARTDATE, 'MONTH') FROM PERSONNEL
WHERE PNAME = 'KIM' --15일 기준으로

SELECT STARTDATE,ROUND(STARTDATE, 'MONTH') FROM PERSONNEL
WHERE PNAME = 'LEE'

SELECT TO_CHAR(SYSDATE, 'YY-MM-DD HH24:MI:SS') FROM PERSONNEL WHERE PNAME ='LEE'

SELECT TO_CHAR(SYSDATE, 'MM-DD-YY HH24:MI:SS') FROM PERSONNEL WHERE PNAME ='LEE'

--TRUNC
SELECT STARTDATE, TRUNC(STARTDATE,'YEAR') FROM PERSONNEL

--MONTH_BETWEEN(달수 구하기)
SELECT ROUND((MONTHS_BETWEEN(SYSDATE,'2002/06/01'))/12) MONTHS FROM DUAL

--LAST_DAY(말일구하기)
SELECT STARTDATE,LAST_DAY(STARTDATE) FROM PERSONNEL --그해의 그달의 마지막날

--NEXT-DAY
SELECT NEXT_DAY('2014-10-13', 'MONDAY') FROM DUAL --돌아오는 월요일 날짜

--ADD_MONTH
SELECT ADD_MONTHS(SYSDATE,24) FROM DUAL

--변환함수
--TO_CHAR(숫자니 날짜를 문자로 변환)

MM: 달수(10)
MON : 3문자 달의 이름(MAR)
MONTH : 달의 완벽한 이름(MARCH)
DD : 달의 날짜수(22)
D : 주의 일수(2)
DY : 3문자 요일(MON)
DAY : 요일이름(MONDAY)
YYYY : 4문자 년도
YY : 2문자 년도
RM : 로마식 달수(X)

SELECT SYSDATE, TO_CHAR(SYSDATE,'D') FROM DUAL
SELECT SYSDATE, TO_CHAR(SYSDATE,'DY') FROM DUAL
SELECT SYSDATE, TO_CHAR(SYSDATE,'RM') FROM DUAL
SELECT SYSDATE, TO_CHAR(SYSDATE,'YYYY') FROM DUAL
SELECT SYSDATE, TO_CHAR(SYSDATE,'DD') FROM DUAL

SELECT SYSDATE, TO_CHAR(SYSDATE,'YY DD') FROM DUAL

SELECT PNAME,TO_CHAR(STARTDATE,'DD-MON-YY') DATE1,
TO_CHAR(STARTDATE,'FM DD-MON-YY') STARTDATE FROM PERSONNEL --FM은 0이 빠진다

--시간형식
HH : 12시간
HH24 : 24시간
MI : 분
SS : 초
SSSS: 초의 자리수
AM, PM: 오전 오후
A.M. , P.M. : 오전오후

SELECT TO_CHAR(SYSDATE, 'HH24:MI:SSSS') FROM DUAL
SELECT TO_CHAR(SYSDATE, 'AMHH:MI') FROM DUAL
SELECT TO_CHAR(SYSDATE, 'AM HH:MI') FROM DUAL
SELECT TO_CHAR(SYSDATE, 'P.M. HH:MI') FROM DUAL

--숫자형식
 9 : 숫자의 위치(99999 -> 1218) --숫자 5자 쓰겟다
 0 : 자리수가 비면 0으로 표시(09999->01234)
 PR : 음수를 괄호로 표시(9999,PR -> <1234>)
 . : 소수점 자리 표시(9999.99 -> 123.89)
 , : 천의 자리를 표시(99,999 -> 1,234)

 SELECT TO_CHAR(12506, '$99,999.99') FROM DUAL

 --기타
 SELECT SYSDATE, TO_CHAR(SYSDATE,'DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DDSP') FROM DUAL;
 SELECT SYSDATE, TO_CHAR(SYSDATE,'DDTH') FROM DUAL;
 SELECT SYSDATE, TO_CHAR(SYSDATE,'DDSPTH') FROM DUAL;

--TO_DATE
SELECT TO_DATE('07-JUL-22', 'YY-MONTH-DD') FROM DUAL
SELECT TO_DATE('11:05', 'HH12:MI') FROM DUAL

--TO_NUMBER
SELECT TO_NUMBER('123')+10 FROM DUAL --문자가 숫자로 바뀌는
SELECT TO_NUMBER('ABC')+10 FROM DUAL --숫자로 바꿀수 있는게 아니니

--NVL
SELECT BONUS,NVL(BONUS,0) FROM PERSONNEL; --NULL이면 0으로 바꾼다

--DECODE
--각 사원의 급여를 부서번호가 10인경우 10%, 부서가 20인경우 20%를
--나머지는 30%를 더해서 출력
SELECT * FROM PERSONNEL

SELECT PNAME,BONUS,DNO,PAY, DECODE(DNO,10,PAY*1.1,20,PAY*1.2,PAY*1.3) "인상분"
FROM PERSONNEL --DECODE는 IF문같이 사용

--급여가 3500이상인 경우 'GOOD' 3500미만 'POOR'를 출력하시오
SELECT PNAME, PAY, DECODE(SIGN(PAY-3499),1,'GOOD','POOR') "GRADE" FROM PERSONNEL

--그룹함수
--COUNT
SELECT COUNT(*) FROM PERSONNEL; --레코드의 총개수를 세워준다
SELECT COUNT(MANAGER) FROM PERSONNEL --COUNT는 널값을 셀수 없다
SELECT MANAGER FROM PERSONNEL

--급여가 3000이상인 사원수
SELECT COUNT(*) FROM PERSONNEL WHERE PAY >= 3000

--AVG평균
SELECT AVG(PAY) FROM PERSONNEL --모든 페이의 평균

SELECT * FROM PERSONNEL

--BONUS의 평균
SELECT AVG(NVL(BONUS,0)) FROM PERSONNEL

--SUM(합계)
SELECT SUM(PAY) FROM PERSONNEL

--MAX/MIN
SELECT MAX(PAY), MIN(PAY) FROM PERSONNEL

--입사한지 가장 오래된 직원
SELECT MIN(STARTDATE) "최고고참", MAX(STARTDATE) "신입" FROM PERSONNEL
SELECT (MAX(STARTDATE)-MIN(STARTDATE))/365 AS 년차 FROM PERSONNEL

--분석함수
--부서별 평균구하기
SELECT DISTINCT DNO, AVG(PAY) OVER(PARTITION BY DNO) FROM PERSONNEL ORDER BY DNO
-- AVG(PAY) OVER(PARTITION BY DNO) -부서별로 구분을 지어서 평균을 구해라

--월급 1200을 받는사람의 순위
SELECT RANK(1200) WITHIN GROUP(ORDER BY PAY DESC) FROM PERSONNEL
-- WITHIN GROUP(ORDER BY PAY DESC) - 페이가 많은 사람순으로 정렬해서

SELECT PNAME, PAY, RANK() OVER(ORDER BY PAY DESC) FROM PERSONNEL

--전체사원의 급여와 함께 부서별 최고급여
SELECT DNO, PAY, FIRST_VALUE(PAY) OVER(PARTITION BY DNO ORDER BY PAY DESC) "부서 최고급여"
FROM PERSONNEL

--GROUP BY
--다중값을 반환하는 쿼리
SELECT PNAME FROM PERSONNEL WHERE PNAME = 'BILL';

--단일값을 반환한다.
SELECT COUNT(*) FROM PERSONNEL

--단일값과 다중값은 같이 사용 못해
SELECT PNAME, COUNT(*) FROM PERSONNEL WHERE PAY >= 3000

--부서별 평균급여
SELECT DNO,AVG(PAY) FROM PERSONNEL
GROUP BY DNO;


--20141014일수업

SELECT * FROM PERSONNEL;

SELECT AA.PNAME 사원, BB.PNAME 관리자
FROM PERSONNEL AA, PERSONNEL BB
WHERE AA.MANAGER = BB.PNO;

SELECT * FROM PERSONNEL;
SELECT * FROM PAYGRADE;

SELECT PNAME, PAY, GRADE
FROM PERSONNEL AA, PAYGRADE BB
WHERE PAY BETWEEN LOWPAY AND HIGHPAY

--고객별 구입한 제품의 총금액, 횟수
SELECT * FROM SALES;

--operation
A=[1,2,5,6] B=[1,2,4]


A UNION ALL B = [1,2,5,6,1,2,4];
A UNION B = [1,2,4,5,6]
A MINUS B = [5,6]
A INTERSECT B = [1,2]

--합집합
SELECT * FROM PERSONNEL
UNION
SELECT * FROM PERSONNEL;

--전체집합
SELECT * FROM PERSONNEL
UNION ALL
SELECT * FROM PERSONNEL;

-- 차집합 40
SELECT DNO FROM DIVISION -- 10,20,30,40
MINUS
SELECT DNO FROM PERSONNEL; --10,20,30

-- 교집합 10, 20, 30
SELECT DNO FROM DIVISION -- 10,20,30,40
INTERSECT
SELECT DNO FROM PERSONNEL; --10,20,30


--PAIRWISE
--부서번호가 '30번'인 직원의 '급여'와 '보너스'가 같은 사원을 검색

SELECT PNAME,DNO,PAY,NVL(BONUS,-1)
FROM PERSONNEL
WHERE (PAY, NVL(BONUS,-1))
IN (SELECT PAY, NVL(BONUS,-1) FROM PERSONNEL WHERE DNO=30);


--NUM PAIRWISE
SELECT PNAME,DNO,PAY,NVL(BONUS,-1)
FROM PERSONNEL
WHERE PAY
IN (SELECT PAY FROM PERSONNEL WHERE DNO=30)
AND NVL(BONUS, -1)
IN (SELECT NVL(BONUS,-1) FROM PERSONNEL WHERE DNO=30);








-------------------------------------------------------------------------------
--dml문장
INSERT, UPDATE, DELETE

SELECT* FROM DIVISION;



CREATE TABLE MANAGER
AS
	SELECT * FROM PERSONNEL
	WHERE 1=2;

CREATE TABLE SALESMAN
AS
	SELECT * FROM PERSONNEL
	WHERE 1=2;

CREATE TABLE BUSEO
AS SELECT * FROM DIVISION;

CREATE TABLE SAWON
AS SELECT * FROM PERSONNEL;

CREATE TABLE EXAM1
AS SELECT * FROM PERSONNEL;

CREATE TABLE EXAM2
AS SELECT * FROM DIVISION;


SELECT * FROM TAB

SELECT * FROM MANAGER;

SELECT * FROM BUSEO

SELECT * FROM DIVISION;
DESC DIVISION;

INSERT INTO DIVISION VALUES(50,'OPERATION','031-123-1234','DAEGU');
SELECT * FROM DIVISION;

DESC PERSONNEL;
INSERT INTO PERSONNEL(PNO, PNAME, PAY, DNO) VALUES(7711, 'YOUNG', 4000, 20)
SELECT * FROM PERSONNEL;


--NULL 입력
INSERT INTO DIVISION(DNO, DNAME, PHONE) VALUES (80, 'PLANNING', '010-1234-1234')
INSERT INTO DIVISION VALUES (90, 'ACCOUNT', '011-342-1234', NULL)
INSERT INTO DIVISION (DNAME) VALUES ('SALES');  --X
DESC DIVISION

INSERT INTO PERSONNEL(PNO, PNAME, JOB, STARTDATE, DNO)
VALUES(1304, 'YOU', 'SALESMAN', SYSDATE, 10);

SELECT * FROM PERSONNEL;

DESC MANAGER;
SELECT COUNT(*) FROM MANAGER;
SELECT * FROM PERSONNEL;

INSERT INTO MANAGER
SELECT * FROM PERSONNEL WHERE JOB = 'MANAGER';

SELECT * FROM MANAGER;

SELECT * FROM SALESMAN;

INSERT INTO SALESMAN(PNO, PNAME, PAY, STARTDATE)
SELECT PNO, PNAME, PAY, STARTDATE FROM PERSONNEL
WHERE JOB = 'SALESMAN';


--문제 설명
SELECT extract(year FROM startdate) FROM PERSONNEL;
SELECT TO_CHAR(startdate,'yyyy') FROM PERSONNEL;

SUM(WHEN 1990 THEN 1 ELSE 0 END)
WHEN 1990 THEN 1 ELSE 0 END)


치환변수
SELECT PNO, PNAME, JOB, STARTDATE, DNO FROM PERSONNEL WHERE DNO=&DIV_DNO;

--UPDATE

--사원번호가 1111인 사원의 부서를 30으로 수정
SELECT * FROM PERSONNEL WHERE PNO=1111;

UPDATE PERSONNEL SET DNO=30 WHERE PNO=1111;

--SAWON테이블의 모든 사원의 부서번호를 20으로 수정

SELECT * FROM SAWON;
UPDATE SAWON SET DNO=20;

UPDATE SAWON SET PNAME='SUZI', JOB='SINGER', MANAGER=1111,PAY=5000
WHERE PNO=1113


SELECT* FROM PERSONNEL
WHERE DNO=(SELECT DNO FROM DIVISION WHERE DNAME='SALES')

UPDATE PERSONNEL SET JOB='SALESMAN'
WHERE DNO=(SELECT DNO FROM DIVISION WHERE DNAME='SALES')

--DELETE
--사원번호가 1300인 사원을 삭제
SELECT * FROM PERSONNEL
WHERE PNO=1123;

DELETE FROM PERSONNEL
WHERE PNO=1123;

SELECT * FROM BUSEO;

SELECT * FROM PERSONNEL;

--INSERT에러
SELECT * FROM PERSONNEL;

DESC PERSONNEL;

SELECT * FROM USER_CONSTRAINTS;
PRIMARY KEY(주키)
중복값을 허용안함
NOT NULL
테이블에 1개만 생성가능

INSERT INTO PERSONNEL (PNAME) VALUES('AAAA');

--수정이불가능한경우

SELECT * FROM DIVISION;
SELECT * FROM PERSONNEL;

FOREIGN KEY(외부참조키)

INSERT INTO PERSONNEL (PNO, DNO) VALUES(1234,10);

SELECT * FROM PERSONNEL;

INSERT INTO PERSONNEL (PNO, DNO) VALUES(1233,15);
--위에 DNO에 없어 안됨
SELECT * FROM PERSONNEL;

UPDATE PERSONNEL SET DNO = 16
WHERE PNO=1111;

DELETE DIVISION WHERE PNO=30;

SELECT * FROM USER_CONSTRAINTS;
SELECT COUNT(*) FROM DICTIONARY;

--TRANSACTION
여러개의 작업을 1개의 작업으로 처리

SELECT * FROM PERSONNEL;

DELETE PERSONNEL WHERE PNO=1112;

























